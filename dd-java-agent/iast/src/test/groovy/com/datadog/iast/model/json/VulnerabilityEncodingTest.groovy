package com.datadog.iast.model.json


import com.datadog.iast.model.Source
import com.datadog.iast.model.SourceType
import com.datadog.iast.model.VulnerabilityBatch
import com.datadog.iast.model.Evidence
import com.datadog.iast.model.Location
import com.datadog.iast.model.VulnerabilityType
import com.datadog.iast.model.Vulnerability
import com.datadog.iast.model.Range
import datadog.trace.test.util.DDSpecification
import groovy.json.JsonSlurper

class VulnerabilityEncodingTest extends DDSpecification {

  void 'one vulnerability'() {
    given:
    final slurper = new JsonSlurper()
    final value = VulnerabilityBatch.forVulnerabilities([
      Vulnerability.builder()
      .type(VulnerabilityType.WEAK_HASH)
      .evidence(new Evidence("MD5"))
      .location(Location.forStack(new StackTraceElement("foo", "foo", "foo", 1)))
      .build()
    ])

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    slurper.parseText(result) == slurper.parseText('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "value": "MD5"
          },
          "location": {
            "line": 1,
            "path": "foo"
          }
        }
      ]
    }''')
  }

  void 'one vulnerability with one source'() {
    given:
    final slurper = new JsonSlurper()
    final value = VulnerabilityBatch.forVulnerabilities([
      Vulnerability.builder()
      .type(VulnerabilityType.WEAK_HASH)
      .evidence(new Evidence("BAD", [new Range(0, 1, new Source(SourceType.REQUEST_PATH, "key", "value"))] as Range[]))
      .location(Location.forStack(new StackTraceElement("foo", "foo", "foo", 1)))
      .build()
    ])

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    slurper.parseText(result) == slurper.parseText('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "value": "BAD",
            "ranges": [
              {
                "length": 1,
                "start": 0,
                "source": 0
              }
            ]
          },
          "location": {
            "line": 1,
            "path": "foo"
          }
        }
      ],
      "sources": [
        {
          "origin": "http.url_details.path",
          "name": "key",
          "value": "value",
        }
      ]
    }''')
  }

  void 'one vulnerability with two sources'() {
    given:
    final slurper = new JsonSlurper()
    final value = VulnerabilityBatch.forVulnerabilities([
      Vulnerability.builder()
      .type(VulnerabilityType.WEAK_HASH)
      .evidence(new Evidence("BAD", [
        new Range(0, 1, new Source(SourceType.REQUEST_PATH, "key", "value")),
        new Range(1, 1, new Source(SourceType.REQUEST_QUERY_PARAMETER, "key2", "value2"))
      ] as Range[]))
      .location(Location.forStack(new StackTraceElement("foo", "foo", "foo", 1)))
      .build()
    ])

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    slurper.parseText(result) == slurper.parseText('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "value": "BAD",
            "ranges": [
              {
                "length": 1,
                "start": 0,
                "source": 0,
              },
              {
                "length": 1,
                "start": 1,
                "source": 1
              }
            ]
          },
          "location": {
            "line": 1,
            "path": "foo"
          }
        }
      ],
      "sources": [
        {
          "origin": "http.url_details.path",
          "name": "key",
          "value": "value"
        },
        {
          "origin": "http.url_details.queryString",
          "name": "key2",
          "value": "value2"
        }
      ]
    }''')
  }

  void 'one vulnerability with null source'() {
    given:
    final slurper = new JsonSlurper()
    final value = VulnerabilityBatch.forVulnerabilities([
      Vulnerability.builder()
      .type(VulnerabilityType.WEAK_HASH)
      .evidence(new Evidence("BAD", [new Range(0, 1, null)] as Range[]))
      .location(Location.forStack(new StackTraceElement("foo", "foo", "foo", 1)))
      .build()
    ])

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    slurper.parseText(result) == slurper.parseText('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "value": "BAD",
            "ranges": [
              {
                "length": 1,
                "start": 0
              }
            ]
          },
          "location": {
            "line": 1,
            "path": "foo"
          }
        }
      ]
    }''')
  }

  void 'one vulnerability with null source type'() {
    given:
    final slurper = new JsonSlurper()
    final value = VulnerabilityBatch.forVulnerabilities([
      Vulnerability.builder()
      .type(VulnerabilityType.WEAK_HASH)
      .evidence(new Evidence("BAD", [new Range(0, 1, new Source(null, "key", "value"))] as Range[]))
      .location(Location.forStack(new StackTraceElement("foo", "foo", "foo", 1)))
      .build()
    ])

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    slurper.parseText(result) == slurper.parseText('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "value": "BAD",
            "ranges": [
              {
                "length": 1,
                "start": 0,
                "source": 0
              }
            ]
          },
          "location": {
            "line": 1,
            "path": "foo"
          }
        }
      ],
      "sources": [
        {
          "name": "key",
          "value": "value",
        }
      ]
    }''')
  }
}
